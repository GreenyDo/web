<!-- 文章标题 -->
<h2>异步编程</h2>
<p class="separate">. . . . . . . . . . . . . . . . . .</p>
<!-- 文章配图 -->
<br/>
<br/>
<div id="center_article">
	<pre><code>
		不要在循环中创建函数
		每创建一个函数对象是需要大批量空间的。所以在一个循环中创建函数是很不明智的，
		尽量将函数移动到循环之前创建，比如如下代码：
		for(var i = 0, m = data.length; i < m; i++) {
		    handlerData(data[i], function(data){
		        //do something
		    });
		}
		可修改为：
		var handler = function(data){
		    //do something
		};
		for(var i = 0, m = data.length; i < m; i++) {
		    handlerData(data[i], handler);
		}
		-------------------------------------------------------------------
		让垃圾回收器回收那些不再需要的对象
		垃圾回收器判断一个对象为活对象还是死对象，是按照是否有活对象或根对象含有对它的引用来判定的。
		如果有根对象或者活对象引用了这个对象，它将被判定为活对象。所以我们需要通过手动消除这些引用来让垃圾回收器对回收这些对象。
		-------------------------------------
		delete
		一种方式是通过delete方式来消除对象中的键值对，从而消除引用。但这种方式并不提倡，它会改变对象的结构，可能导致引擎中对对象的存储方式变更，降级为字典方式进行存储不利于JavaScript引擎的优化，所以尽量减少使用
		-------------------------------------
		null
		另一种方式是通过将值设为null来消除引用。通过将变量或对象的属性设为null，可以消除引用，使原本引用的对象成为一个“孤岛”，然后在垃圾回收的时候对其进行回收。这种方式不会改变对象的结构，比使用delete要好
		-------------------------------------
		合理使用全局对象
		另外需要注意的是，垃圾回收器认为根对象永远是活对象，永远不会对其进行垃圾回收。而全局对象就是根对象，所以全局作用域中的变量将会一直存在
		-------------------------------------
		事件处理器的回收
		在平常写代码的时候，我们经常会给一个DOM节点绑定事件处理器，但有时候我们不需要这些事件处理器后，就不管它们了，它们默默的在内存中保存着。所以在某些DOM节点绑定的事件处理器不需要后，我们应当销毁它们。同时绑定的时候也尽量使用事件代理的方式进行绑定，以免造成多次重复的绑定导致内存空间的浪费。
		-------------------------------------
		慎用eval和with
		-------------------------------------
		缓存正则表达式对象
		需要注意，正则表达式对象的创建非常消耗时间，尽量不要在循环中创建正则表达式，尽可能多的对正则表达式对象进行复用
		-------------------------------------
		考虑对象和数组
		在JavaScript中我们可以使用两种存放数据：对象和数组。由于JavaScript数组可以存放任意类型数据这样的灵活性，导致我们经常需要考虑何时使用数组，何时使用对象。我们应当在如下情况下做出考虑：
		1. 存储一串相同类型的对象，应当使用数组
		2. 存储一堆键值对，值的类型多样，应当使用对象
		3. 所有值都是通过整数索引，应当使用数组
		数组使用时的优化
		往数组中插入混合类型很容易降低数组使用的效率，尽量保持数组中元素的类型一致
		-------------------------------------
		对象的拷贝
		需要注意的是，JavaScript遍历对象和数组时，使用for...in的效率相当低，所以在拷贝对象时，如果已知需要被拷贝的对象的属性，通过直接赋值的方式比使用for...in方式要来得快，代码：
		function copy(source){
		    var result = {};
		    var item;
		    for(item in source) {
		        result[item] = source[item];
		    }
		    return result;
		}
		var backup = copy(source);
		可修改为：
		function copy(source){
		    this.property1 = source.property1;
		    this.property2 = source.property2;
		    this.property3 = source.property3;
		    //...
		}
		var backup = new copy(source);
		字面量代替构造函数
		JavaScript可以通过字面量来构造对象，比如通过[]构造一个数组，{}构造一个对象，/regexp/构造一个正则表达式，我们应当尽力使用字面量来构造对象，因为字面量是引擎直接解释执行的，而如果使用构造函数的话，需要调用一个内部构造器，所以字面量略微要快一点点。
		-------------------------------------------------------------------
		缓存AJAX
		可看到访问网络资源是相当慢的，而AJAX就是JavaScript访问网络资源的方式，所以对一些AJAX结果进行缓存，可以大大减少响应时间。
		---------------------------------------
		函数缓存
		我们可以使用前面缓存复杂计算函数结果的方式进行缓存，通过在函数对象上构造cache对象，原理一样，这里略过。这种方式是精确到函数，而不精确到请求
		---------------------------------------
		本地缓存
		HTML5提供了本地缓存sessionStorage和localStorage，区别就是前者在浏览器关闭后会自动释放，而后者则是永久的，不会被释放。它提供的缓存大小以MB为单位，比cookie（4KB）要大得多，所以我们可以根据AJAX数据的存活时间来判断是存放在sessionStorage还是localStorage当中。
		-------------------------------------------------------------------
		使用布尔表达式的短路
		在很多语言中，如果bool表达式的值已经能通过前面的条件确定，那么后面的判断条件将不再会执行，
		---------------------------------------
		使用原生方法
		尽量使用诸如Math之类的原生对象和方法
		---------------------------------------
		使用web worker
		web worker是HTML5提出的一项新技术，通过多线程的方式为JavaScript提供并行计算的能力，通过message的方式进行相互之间的信息传递。
		-------------------------------------------------------------------
		JavaScript文件的
		使用CDN
		在编写JavaScript代码中，将这些库文件放在CDN（内容分发网络上），这样能大大减少响应时间
		----------------------------------------
		压缩与合并JavaScript文件
		通过uglify的算法，还可以缩减变量名和函数名，从而将JS代码压缩，节约传输时的带宽。减少HTTP的请求次数。
		----------------------------------------
		使用Application Cache缓存
	</code></pre>
</div>