<!-- 文章标题 -->
<h2>异步I/O</h2>
<p class="separate">. . . . . . . . . . . . . . . . . .</p>
<!-- 文章配图 -->
<br/>
<br/>
<div id="center_article">
	<h4>为什么要异步I/O？</h4><br/>
	如果网页通过同步的方式获取，那么javascript需要等待资源完全从服务器端获取后才能继续执行，不能立刻响应用户的交互行为，非常影响用户体验。<br/>
	但是，如果采用异步方式，第一个资源的获取并不会阻塞第二个资源。<br/>
	<br/>
	<h4>资源分配</h4><br/>
	多线程：代价在于创建线程和执行线程上下文切换的开销较大，但是在多核CPU上能够有效提升CPU的利用率。<br/>
	单线程：串行执行的缺点在于性能，任意一个略慢的任务都会导致后续执行代码被阻塞。<br/>
	node解决方式：利用单线程，远离多线程死锁、状态同步等问题，利用异步I/O,让单线程远离阻塞，以更好地使用CPU。<br/>
	<br/>
	为了获取完整的数据，应用程序需要重复调用I/O操作来确认是否完成，这种重复调用判断操作是否完成的技术叫做轮询。<br/>
	在进程启动时，Node便会创建一个类似与while的循环，每执行一次循环体的过程成为Tick，每个Tick过程就是查看是否有事件待处理，如果有，就取出事件极其相关的回调函数，如果存在关联的回调函数就执行它们，然后进入下个循环，如果不再有事件处理，就退出进程。<br/>
	每个事件循环中有一个或多个<b>观察者</b>，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件。<br/>
	node中，事件主要来源于网络请求、文件I/O。事件循环是一个典型的生产者/消费者模型。<br/><br/>
	<h4>异步I/O流程：</h4><br/>
	1.异步调用：发起异步调用->封装请求对象->设置参数和回调函数->将请求对象放入线程池等待执行。<br/>
	2.线程池：线程可用->执行请求对象中的I/O操作->将结果放在请求对象中->通知IOCP调用完成->归还线程。<br/>
	3.事件循环：创建主循环->从I/O观察者取到可用的请求对象->取出回调函数和结果调用执行->获取完成I/O交给I/O观察者。<br/>
	事件循环、观察者、请求对象、I/O线程池共同构成了Node异步I/O模型的基本要素。
</div>