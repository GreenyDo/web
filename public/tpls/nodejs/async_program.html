<!-- 文章标题 -->
<h2>异步编程</h2>
<p class="separate">. . . . . . . . . . . . . . . . . .</p>
<!-- 文章配图 -->
<br/>
<br/>
<div id="center_article">
	Node中异步编程借助异步I/O模型及V8引擎，突破单线程的性能瓶颈，让javascript在后端达到实用价值，也统一了前后端javascript的编程模型。
	<br/>
	难点：异常处理、函数嵌套过深、阻塞代码、多线程编程、异步转同步。	<br/><br/>
	<h4>异步编程解决方案</h4>
	事件监听器模式。利用events模块，具有addListener/on()、once()、removeListener()、removeAllListeners()和emit()等基本的事件监听模式的方法实现。事件监听模式也是一种钩子机制，利用钩子导出内部数据或状态给外部的调用者，node中的很多对象大多具有黑盒的特点，功能点较少，如果不通过事件钩子的形式，我们就无法获取对象在运行期间的中间值或内部状态。<br/>
	Promise/Deferred模式：先执行异步调用，延迟传递处理。异步的广度使用使得回调、嵌套出现，但是一旦出现深度的嵌套，就会让编程的体验变得不愉快，此模式一定程度上缓解了这个问题。<br/>
	<h4>流程控制库</h4> 
	1.尾触发与next <br/>
	除了事件和Promise外，还有一类方法是需要手工调用才能持续执行后续调用的，此类方法叫做尾触发，常见next，尾 触发目前应用最多的地方是Connect的中间件。<br/>
	<pre><code>
	var app = connect();
	app.use(connect.session());
	</code></pre>
	 通过use()方法注册好一系列中间件后，监听端口上的请求，中间件利用尾触发的机制。<br/>
	 <pre><code>
	 function (req, res, next) {
	 //中间件
	}
	</code></pre>
	<br/>
	每个中间件传递请求对象、响应对象、和尾触发函数，通过队列形成一个处理流。中间件机制使得在处理网络请求时，可以像面向编程一样进行过滤、验证、日志等功能，而不与具体业务逻辑产生关联。<br/>
	2.async <br/>
	series()适合无依赖的异步串行执行，但当前一个的结果是后一个调用的输入时，series()方法就无法满足需求了。async提供了waterfall()方法来满足。
</div>